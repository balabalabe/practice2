//方法一，交换式插入排序
void insertionSort(int a[],int length){//细节，为什么要传入数组的长度length而不直接sizeof(a)/sizeof(int)
    if(a==null){
        return ;
    }
    for(int i=1;i<length;i++){//默认首元素是有序的，所以循环从第二个元素开始
        for(int j=i-1;j>=0 && a[j]>a[j+1];j--){
            swap(a[j],a[j+1]);
        }
    }
}//以上面的第四次插入为例，交换式插入的思想跟冒泡排序差不多，每次将一个最小元素冒泡到一个合适的位置
//0和7比较，7比0大，所以交换位置，数组变为3,5,6,0,7
//0和6比较，6比0大，所以交换位置，数组变为3,5,0,6,7
//0和5比较，5比0大，所以交换位置，数组变为3,0,5,6,7
//0和3比较，3比0大，所以交换位置，数组变为0,3,5,6,7

//方法二，覆盖式插入排序
void insertionSort(int a[],int length){
    if(a==null){
        return ;
    }
    int j=0;
    for(int i=1;i<length;i++){//默认首元素是有序的，所以循环从第二个元素开始
        int temp=a[i];//保存待插入元素
        for(j=i-1;j>=0 && a[j]>a[i];j--){
            a[j+1]=a[j];//比待插入元素a[i]大的，整体往后搬一格
        }
        a[j+1]=temp;//在比a[i]小的元素后面插入待插入元素
    }
}//例如，有1,2,4,5,3,6,7其中1,2,4,5是已经排好序的3,6,7是待排序的。此时取3作为待插入元素
//3和5比较，5比3大所以5往后覆盖一格，数组变为1,2,4,5,5,6,7
//3和4比较，4比3大所以4也往后覆盖一格，数组变成1,2,4,4,5,6,7
//3和2比较，2比3小符合条件，因此3插入到2的后面，数组变成1,2,3,4,5,6,7
